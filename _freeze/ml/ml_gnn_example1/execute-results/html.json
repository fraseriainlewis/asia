{
  "hash": "097508295840a8bd94a90be4e743f7b6",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"tf_gnn_example\"\noutput: \n  rmarkdown::html_vignette:\n    toc: true\n    toc_depth: 2\n    number_sections: true\nvignette: >\n  %\\VignetteIndexEntry{tf_gnn_example}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#library(tfclinical)\nlibrary(ragg)\nlibrary(reticulate)\nuse_virtualenv(\"/Users/work/gnn\", required = TRUE)\n# 1. Set the device to 'png' (which both R and Python understand)\nknitr::opts_chunk$set(dev = \"png\")\n\n# 2. Tell R to use ragg as the default engine for all png devices\noptions(device = function(...) ragg::agg_png(...))\n```\n:::\n\n\n## Graphical Neural Network Model\n\nGraphical Neural Networks are increasingly finding application in drug development beyond their historical major use case of prediction and classification of new potential drug molecules. Newer applications include extending to electronic patient records for prediction of future disease outcomes.\n\nThis example is ported from the [original on Tensorflow GNN github site](https://colab.research.google.com/github/tensorflow/gnn/blob/master/examples/notebooks/intro_mutag_example.ipynb). Unlike other vignettes, a custom Python setup is required here for reticulate so as ensure correct version compatibility of tensorflow and tensorflow-gnn. See installation guide under advanced.\n\nNeeds compatible versions (installed via pip in venv hard coding versions):\n\n-   Python: 3.11.14\n-   Name: tf_keras\n    -   Version: 2.16.0\n-   Name: tensorflow\n    -   Version: 2.16.2\n-   Name: tensorflow-gnn\n    -   Version: 1.0.3\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport os\nos.environ[\"TF_USE_LEGACY_KERAS\"] = \"1\"  # For TF2.16+.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport tensorflow as tf\nimport tensorflow_gnn as tfgnn\n\nprint(f'Running TF-GNN {tfgnn.__version__} with TensorFlow {tf.__version__}.')\n\n\n\n\ntrain_path = os.path.join(os.getcwd(), 'precomputed/mutag', 'train.tfrecords')\nval_path = os.path.join(os.getcwd(), 'precomputed/mutag', 'val.tfrecords')\n#get_ipython().system('ls -l {train_path} {val_path}')\n\nprint(f\" the train path={train_path}\")\n#exit()\n\n\ngraph_tensor_spec = tfgnn.GraphTensorSpec.from_piece_specs(\n    context_spec=tfgnn.ContextSpec.from_field_specs(features_spec={\n                  'label': tf.TensorSpec(shape=(1,), dtype=tf.int32)\n    }),\n    node_sets_spec={\n        'atoms':\n            tfgnn.NodeSetSpec.from_field_specs(\n                features_spec={\n                    tfgnn.HIDDEN_STATE:\n                        tf.TensorSpec((None, 7), tf.float32)\n                },\n                sizes_spec=tf.TensorSpec((1,), tf.int32))\n    },\n    edge_sets_spec={\n        'bonds':\n            tfgnn.EdgeSetSpec.from_field_specs(\n                features_spec={\n                    tfgnn.HIDDEN_STATE:\n                        tf.TensorSpec((None, 4), tf.float32)\n                },\n                sizes_spec=tf.TensorSpec((1,), tf.int32),\n                adjacency_spec=tfgnn.AdjacencySpec.from_incident_node_sets(\n                    'atoms', 'atoms'))\n    })\n\n\ndef decode_fn(record_bytes):\n  graph = tfgnn.parse_single_example(\n      graph_tensor_spec, record_bytes, validate=True)\n\n  # extract label from context and remove from input graph\n  context_features = graph.context.get_features_dict()\n  label = context_features.pop('label')\n  new_graph = graph.replace_features(context=context_features)\n\n  return new_graph, label\n\n\n# In[7]:\n\n\ntrain_ds = tf.data.TFRecordDataset([train_path]).map(decode_fn)\nval_ds = tf.data.TFRecordDataset([val_path]).map(decode_fn)\n\n\n# ### Look at one example from the dataset\n\n# In[8]:\n\n\ng, y = train_ds.take(1).get_single_element()\n\n\n# #### Node features\n# \n# Node features represent the 1-hot encoding of the atom type (0=C, 1=N, 2=O, 3=F,\n# 4=I, 5=Cl, 6=Br).\n\n# In[9]:\n\n\nprint(g.node_sets['atoms'].features[tfgnn.HIDDEN_STATE])\n\n\n# #### Bond Edges\n# \n# In this example, we consider the bonds between atoms undirected edges. To encode\n# them in the GraphsTuple, we store the undirected edges as pairs of directed\n# edges in both directions.\n# \n# `adjacency.source` contains the source node indices, and `adjacency.target` contains the corresponding target node indices.\n\n# In[10]:\n\n\ng.edge_sets['bonds'].adjacency.source\n\n\n# In[11]:\n\n\ng.edge_sets['bonds'].adjacency.target\n\n\n# #### Edge features\n# \n# Edge features represent the bond type as one-hot encoding.\n\n# In[12]:\n\n\ng.edge_sets['bonds'].features[tfgnn.HIDDEN_STATE]\n\n\n# ### Label\n# The label is binary, indicating the mutagenicity of the molecule. It's either 0 or 1.\n\n# In[13]:\n\n\ny\n```\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n#for k, hist in history.history.items():\n#  plt.plot(hist)\n#  plt.title(k)\n#  plt.show()\nfor k, hist in history.history.items():\n    plt.figure()  # Create a new figure for each metric\n    plt.plot(hist)\n    plt.title(k)\n    plt.xlabel('Epoch')\n    plt.ylabel(k)\n    \n    # Save the plot. Using f-strings to name the file based on the key (e.g., loss.png)\n    #plt.savefig(f\"precomputed/pyplot_{k}.png\")\n    \n    # Optional: If you want to show it in the console while running\n    # plt.show() \n    \n    #plt.close() \n    \n\n# Feel free to play with the hyperparameters and the model architecture to improve the results!\n\n```\n:::\n\n\n## the end\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}